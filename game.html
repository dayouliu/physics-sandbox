<html>
  <body>
    <div id="canvas"></div>
  </body>
</html>

<style>
  html, body, #canvas {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background-color: red;
  }
</style>

<script src="pixi.js"></script>

<script>

  class Debug {

    // enables or disables reporting
    static active = true;

    static log(report) {
      if(Debug.active) {
        if(report.type === 'info') {
          console.log('MESSAGE: ' + report.msg);
        } else if(report.type === 'error' || report.type === 'fatal') {
          console.log('ERROR: ' + report.msg);
        }
      }
    }

    static set active(status) {
      Debug.active = status;
    }

  }

  class Vector {

    x = 0;
    y = 0;

    constructor(x, y) {
      this.x = x;
      this.y = y;
    }

    zero() {
      return (this.x == 0 && this.y == 0);
    }

    add(vec) {
      return new Vector(this.x + vec.x, this.y + vec.y);
    }

    sub(vec) {
      return new Vector(this.x - vec.x, this.y - vec.y);
    }

    scale(factor) {
      return new Vector(this.x * factor, this.y * factor);
    }

    // vector properties

    mag() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    normalize() {
      if(this.zero()) {
        Debug.log({type: 'error', msg: 'vector normalize error'});
      }
      return this.scale(1 / this.mag());
    }

    dot(vec) {
      return this.x * vec.x + this.y * vec.y;
    }

    // project vec onto this
    proj(vec) {
      if(this.zero()) {
        Debug.log({type: 'error', msg: 'vector projection error'});
      }
      var coeff = this.dot(vec) / Math.pow(this.mag(), 2);
      return this.scale(coeff);
    }

    perp(vec) {
      var p = vec.sub(this.proj(vec));
      return p;
    }

    // idk the exact why
    projShape(shape) {
      if(shape instanceof Polygon) {
        var min = this.dot(shape.vertices[0]);
        var max = min;
        for(var i = 1; i < shape.vertices.length; ++i) {
          var dp = this.dot(shape.vertices[i]);
          if(dp < min) {
            min = dp;
          } else if(dp > max) {
            max = dp;
          }
        }
        return new Vector(min, max);
      }
      else if(shape instanceof Circle) {

      }
    }

    // normalized normal
    normal() {
      var n = new Vector(-this.y, this.x);
      return n.normalize();
    }

    rotate(pivot, dr) {
      var vec = this.sub(pivot);
      vec.x = vec.x * Math.cos(dr) - vec.y * Math.sin(dr);
      vec.y = vec.x * Math.sin(dr) + vec.y * Math.cos(dr);
      return vec.add(pivot);
    }

    // interval properties

    contains(num) {
      return this.x <= num && num <= this.y;
    }

    overlap(interval) {
      /*
      console.log(this.contains(interval.x));
      console.log(this.contains(interval.y));
      console.log(interval.contains(this.x));
      console.log(interval.contains(this.y));
      */
      var bool =
        this.contains(interval.x) || this.contains(interval.y) ||
        interval.contains(this.x) || interval.contains(this.y);
        return bool;
    }

    toString() {
      return '[' + this.x + ', ' + this.y + ']';
    }

  }

  class Shape {

    center = new Vector(0, 0);

    constructor(center) {
      this.center = center;
    }

  }

  class Circle extends Shape {

    radius = 0;

    constructor(center, radius) {
      super(center);
      this.radius = radius;
    }

  }

  class Polygon extends Shape {

    vertices = []; // array of Vector

    constructor(center, vertices) {
      super(center);
      this.vertices = vertices;
      // this.translate(center.x, center.y); // WTF???
    }

    edges() {
      var len = this.vertices.length;
      var edges = [];
      edges.push(this.vertices[0].sub(this.vertices[len-1]));
      for(var i = 1; i < len; ++i) {
        var edge = this.vertices[i].sub(this.vertices[i-1]);
        edges.push(edge);
      }
      return edges;
    }

    translate(dx, dy) {
      for(var i  = 0; i < this.vertices.length; ++i) {
        this.vertices[i].x += dx;
        this.vertices[i].y += dy;
      }
    }

  }

  class Entity {

    game = null;

    rot = 0;
    pos = new Vector(0, 0);
    v = new Vector(0, 0);

    shape = null;
    sprite = null;

    constructor(game, x, y, shape) {
      this.game = game;
      this.pos.x = x;
      this.pos.y = y;
      this.rot = 0;
      this.shape = shape;
      this.sprite = game.draw.drawShape(shape);
    }

    translate(dx, dy) {
      this.pos.x += dx;
      this.pos.y += dy;
      this.shape.center.x = this.pos.x;
      this.shape.center.y = this.pos.y;
      if(this.shape instanceof Polygon) {
        for(var i  = 0; i < this.shape.vertices.length; ++i) {
          this.shape.vertices[i].x += dx;
          this.shape.vertices[i].y += dy;
        }
      }
    }

    rotate(dr) {
      this.rot += dr;
      if(this.shape instanceof Polygon) {
        for(var i  = 0; i < this.shape.vertices.length; ++i) {
          this.shape.vertices[i] =
            this.shape.vertices[i].rotate(this.shape.center, dr);
        }
      }
    }

    draw() {}

    update() {}

  }

  class Mob extends Entity {



    constructor(game, x, y) {
      super(game, x, y);
    }

    accelerate(dv) {
      this.v = this.v.add(dv);
    }

  }

  class Tribox extends Mob {

    constructor(game, x, y) {
      super(game, x, y);
      this.draw();
    }

    draw() {
      var base = 60;
      var height = 30 * Math.sqrt(3);

      var p1 = new Vector(0, height/2);
      var p2 = new Vector(base/2, -height/2);
      var p3 = new Vector(-base/2, -height/2);

      this.sprite = this.game.draw.triangle(p1, p2, p3);

      var v1 = p1.add(this.pos);
      var v2 = p2.add(this.pos);
      var v3 = p3.add(this.pos);
      var vertices = [v1, v2, v3];

      this.shape = new Polygon(this.pos, vertices);
    }

    update() {
      /*
      var vert = '';
      for(var i = 0; i < this.shape.vertices.length; ++i) {
        vert += this.shape.vertices[i].toString();
      }
      console.log(vert);
      */
    }

  }

  class Collision {

    game = null;

    constructor(game) {
      this.game = game;
    }

    detect(s1, s2) {
      // console.log(s1.vertices);
      // console.log(s2.vertices);
      var edges = (s1.edges()).concat(s2.edges());

      var overlapMin = null;
      var overlapDir = null;

      // console.log(edges)
      for(var i = 0; i < edges.length; ++i) {
        var axis = edges[i].normal();
        var proj1 = axis.projShape(s1);
        var proj2 = axis.projShape(s2);
        if(!proj1.overlap(proj2)) {
          // console.log(proj1);
          // console.log(proj2);
          return false;
        } else {
          var overlap = Math.abs(
            Math.min(proj1.y, proj2.y) - Math.max(proj1.x, proj2.x)
          );
          if(overlapMin == null || overlap < overlapMin) {
            overlapMin = overlap;
            overlapDir = axis;
          }
        }
      }

      // return mtv
      var mtv = (overlapDir.normalize()).scale(overlapMin);
      return mtv;
    }

  }

  class EntityManager {

    entities = [];
    player = null;
    collision = new Collision(game);

    update() {
      this.player.update();
      var len = this.entities.length;
      for(var i = 0; i < len; ++i) {
        var entity = this.entities[i];
        if(!(entity instanceof Player)) {
          entity.update();
        }
      }

      for(var i = 0; i < len; ++i) {
        var entity = this.entities[i];
        if(!(this.player == entity)) {
          var collide = this.collision.detect(
            this.player.shape, entity.shape
          );
          // console.log(collide);
          if(collide !== false) {
            this.player.translate(collide.x, collide.y);
          }
        }
      }
    }

    add(entity) {
      this.entities.push(entity);
    }

    addPlayer(player) {
      this.player = player;
      this.entities.push(player);
    }

  }

  class Draw {

    renderer = null;
    stage = null;

    constructor() {
      // admit to being a jerk face
      PIXI.utils.skipHello();

      this.renderer = new PIXI.Renderer({
        antialias: true
      });

      this.stage = new PIXI.Container();

      document.getElementById('canvas').appendChild(this.renderer.view);
      Debug.log({type: 'info', msg: 'draw initialized'});
    }

    render() {
      this.renderer.render(this.stage);
    }

    text(x, y, msg) {
      const style = new PIXI.TextStyle({
          fontFamily: 'Arial',
          fontSize: 36,
          fill: '#ffffff', // gradient
          stroke: '#4a1850',
          strokeThickness: 5,
      });
      var g = new PIXI.Text(msg, style);
      g.x = x;
      g.y = y;
      this.stage.addChild(g);
      return g;
    }

    // circle is drawn relative to origin
    circle(center, radius) {
      var g = new PIXI.Graphics();
      g.beginFill(0xC34288);
      g.drawCircle(0, 0, radius);
      g.endFill();
      this.stage.addChild(g);
      return g;
    }

    // triangle is drawn relative to origin
    triangle(p1, p2, p3) {
      var g = new PIXI.Graphics();
      g.beginFill(0xFF3300);
      g.moveTo(p1.x, -p1.y);
      g.lineTo(p2.x, -p2.y);
      g.lineTo(p3.x, -p3.y);
      g.lineTo(p1.x, -p1.y);
      g.closePath();
      g.endFill();
      this.stage.addChild(g);
      return g;
    }

    polygon(points) {
      var g = new PIXI.Graphics();
      g.beginFill(0xFF3300);
      g.moveTo(points[0].x, -points[0].y);
      for(var i = 1; i < points.length; ++i) {
        g.lineTo(points[i].x, -points[i].y);
      }
      g.lineTo(points[0].x, -points[0].y);
      g.closePath();
      g.endFill();
      this.stage.addChild(g);
      return g;
    }

  }

  class Input {

    keys = [];
    left = 37;
    up = 38;
    right = 39;
    down = 40;

    checkPress(key) {
      return this.keys[key] === true;
    }

    keyDown(key) {
      this.keys[key] = true;
    }

    keyUp(key){
      this.keys[key] = false;
    }

  }

   class Camera {

     // world using cartesian coordinate system

     // pixi js system is right => +
     //                   down  => +

     game = null;
     center = true;

     constructor(game) {
       this.game = game;
     }

     update() {
       if(this.center) {
         var entities = this.game.entityManager.entities;
         // var player = this.game.entityManager.player;
         var width = this.game.draw.renderer.width;
         var height = this.game.draw.renderer.height;
         var ox = width / 2;
         var oy = height / 2;

         player.sprite.position.x = ox; // + player.v.x * 10;
         player.sprite.position.y = oy; // - player.v.y * 10;
         // player.sprite.rotation = -player.rot;

         for(var i = 0; i < entities.length; ++i) {
           var entity = entities[i];
           if(!(entity instanceof Player)) {
             entity.sprite.position.x = player.sprite.position.x + (entity.pos.x - player.pos.x);
             entity.sprite.position.y = player.sprite.position.y - (entity.pos.y - player.pos.y);
             // console.log(player.pos.y);
          }
         }
       }
     }

   }

  class Game {

    draw = null;
    input = null;
    reports = null;
    entityManager = null;
    camera = null;
    fps = null;

    constructor() {
      // init graphics
      this.draw = new Draw();

      this.input = new Input();

      // init resize event
      this.resize();

      this.entityManager = new EntityManager();

      this.camera = new Camera(this);

      if(Debug.active) {
        this.fps = this.draw.text(1, 1, fps);
      }

      Debug.log({type: 'info', msg: 'game initialized'});
    }

    // resize event
    resize() {
      this.draw.renderer.resize(window.innerWidth, window.innerHeight);
      Debug.log({type: 'info', msg: 'window resized'});
    }

    update() {
      this.entityManager.update();
      this.camera.update();
      this.fps.text = Math.floor(fps);
    }

    render() {
      this.draw.render();
    }

  }

  var game = new Game();

  var previous = 0;
  var cap = 80;
  var delta = 0;
  var step = 1000 / cap;

  var elapse = 0;
  var frames = 0;
  var fps = 0;
  var frame = 0;

  function loop(time) {
    elapse = time - previous;
    delta = elapse;
    previous = time;

    while(delta >= step) {
      game.update();
      delta -= step;
      ++frames;
    }

    fps = frames / (elapse / 1000);
    frames = 0;

    game.render();
    requestAnimationFrame(loop);
  }

  function keysDown(e) {
    e = e || window.event;
    game.input.keyDown(e.keyCode);
  }

  function keysUp(e) {
    e = e || window.event;
    game.input.keyUp(e.keyCode);
  }

  // testing

  var caseCounter = 1;

  function assert(bool) {
    if(bool) {
      console.log('test case ' + caseCounter + ': assert passed');
    } else {
      console.log('test case ' + caseCounter + ': assert failed');
    }
    ++caseCounter;
  }

  function approx(a, b) {
    var epsilon = 0.001;
    var delta = Math.abs(a - b);
    return delta < epsilon;
  }

  function test() {
    // test vector basic

    var v1 = new Vector(1, 3);
    var v2 = new Vector(3, 2);

    // 1
    assert(approx(v1.mag(), 3.16227));

    var s1 = v1.scale(3.1);

    // 2
    assert(approx(s1.x, v1.x * 3.1));
    assert(approx(s1.y, v1.y * 3.1));

    var p1 = v1.proj(v2);

    // 4
    assert(approx(p1.x, 9 / 10));
    assert(approx(p1.y, 27/ 10));

    var r1 = v1.rotate(v2, 3);
    // console.log(r1);
    // assert(approx(r1.x, -2.809843422391));
    //  assert(approx(r1.y, 1.4507859737556));

    var n1 = v1.normal();

    // 6
    assert(approx(n1.x, -0.94868329805));
    assert(approx(n1.y, 0.31622776601));
    assert(v1.dot(n1) == 0);

    var v3 = new Vector(2, 4);
    var v4 = new Vector(3, 6.6)

    // 9
    assert(v1.overlap(v3));
    assert(v4.overlap(v2));

    var vt1 = [
      new Vector(1, 2), new Vector(3,4),
      new Vector(5, 4.3), new Vector(-3, -3)
    ];
    var xa = new Vector(1, 0);
    var sh1 = new Polygon(new Vector(0, 0), vt1);
    var p2 = xa.projShape(sh1);

    // 11
    assert(p2.x == -3);
    assert(p2.y == 5);

    // test collision
    var collision = new Collision(null);

    var rec1 = new Polygon(
      new Vector(0, 0),
      [
        new Vector(-1, 1), new Vector(1, 1),
        new Vector(1, -1), new Vector(-1, -1)
      ]
    );

    var rec2 = new Polygon(
      new Vector(0, 0),
      [
        new Vector(0, 2.5), new Vector(2.5, 2.5),
        new Vector(2.5, 0), new Vector(0, 0)
      ]
    );

    // 13
    assert(collision.detect(rec1, rec2));

    var tri1 = new Polygon(
      new Vector(0, 0),
      [new Vector(0, 1), new Vector(1, -2), new Vector(-1, -2)]
    );

    var tri2 = new Polygon(
      new Vector(0, 0),
      [new Vector(0, -1), new Vector(1, 1), new Vector(1, -1)]
    );

    var tri3 = new Polygon(
      new Vector(0, 0),
      [new Vector(3, 1), new Vector(4, -2), new Vector(2, -2)]
    );

    // 14
    assert(collision.detect(tri1, tri2));
    assert(!collision.detect(tri1, tri3));

    var tri4 = new Polygon(
      new Vector(1, 11),
      [new Vector(-2, 2), new Vector(4, 6), new Vector(1, -1)]
    );

    var tri5 = new Polygon(
      new Vector(2, 22),
      [new Vector(4, 0), new Vector(-2, -1), new Vector(2, 6)]
    );

    // 16
    assert(collision.detect(tri4, tri5));

    assert((new Vector(1, 3)).overlap(new Vector(2, 4)));

  }

  test();


  function run() {
    game.entityManager.addPlayer(new Player(game, 0, 0));

    // planet test basic 1
    // game.entityManager.add(new Planet(game, 200, 200, 100));

    // collision test basic 1
    game.entityManager.add(new Tribox(game, 300, 300));

    window.addEventListener("resize", function() {game.resize()});
    document.onkeydown = keysDown;
    document.onkeyup = keysUp;
    requestAnimationFrame(loop);
  }

  run();

</script>
